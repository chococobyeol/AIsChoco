<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>Tarot Overlay Lo-fi</title>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3/dist/gsap.min.js"></script>
  <!-- 폰트 변경: Pretendard -> Gowun Dodum (채팅창과 통일) -->
  <link href="https://fonts.googleapis.com/css2?family=Gowun+Dodum&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body { 
      font-family: 'Gowun Dodum', sans-serif; /* 폰트 적용 */
      background: transparent; 
      overflow: hidden; 
      width: 100vw; height: 100vh;
      color: #f1f5f9; /* 약간 부드러운 흰색 */
    }

    #dimmer {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(20, 20, 25, 0.7); /* 너무 까맣지 않게 */
      backdrop-filter: blur(4px); /* 배경을 살짝 흐리게 해서 집중도 UP */
      opacity: 0; transition: opacity 0.5s; z-index: 0;
    }
    #dimmer.active { opacity: 1; }

    #app { position: relative; width: 100%; height: 100%; z-index: 1; }

    /* [1] 선택 단계 */
    .phase-select {
      position: absolute; width: 100%; height: 100%;
      display: flex; flex-direction: column; justify-content: flex-end;
      padding-bottom: 80px; 
    }
    .select-info { position: absolute; top: 20%; width: 100%; text-align: center; }
    
    /* 타이틀 색상: 쨍한 노랑 -> 은은한 살구색/파스텔 옐로우 */
    .select-title { 
      font-size: 38px; font-weight: bold; 
      color: #fcd34d; 
      text-shadow: 0 4px 15px rgba(0,0,0,0.5); 
    }
    .select-sub { font-size: 22px; color: #cbd5e1; margin-top: 10px; }

    .deck-area { position: relative; width: 100%; height: 300px; bottom: 20px; }
    .card-fan-item {
      position: absolute; width: 60px; height: 100px;
      background: url('/tarot-assets/tarot_back.png') no-repeat center/cover;
      border-radius: 6px; bottom: 0; left: 50%;
      transform-origin: 50% 150%;
      box-shadow: -2px 2px 5px rgba(0,0,0,0.5);
      transition: transform 0.3s;
    }
    .card-fan-item.picked {
      bottom: 50px; 
      border: 2px solid #fcd34d; 
      box-shadow: 0 0 20px rgba(251, 191, 36, 0.6); /* 은은한 발광 */
      z-index: 100;
    }

    /* [2] 결과 단계 */
    .phase-reveal {
      position: absolute; top: 50%; left: 50%; 
      transform: translate(-50%, -50%);
      width: 95%; max-width: 1300px;
      display: flex; flex-direction: column; align-items: center;
    }

    .cards-container {
      display: flex; justify-content: center; gap: 20px;
      margin-bottom: 25px; height: 230px; width: 100%;
    }

    .card-slot {
      position: relative;
      width: 140px; height: 230px;
      background-size: cover; background-position: center;
      border-radius: 12px;
      box-shadow: 0 15px 35px rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.2);
      background-image: url('/tarot-assets/tarot_back.png');
      opacity: 0; transform: translateY(20px);
    }
    .card-back-number {
      position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
      font-size: 42px; font-weight: bold; color: rgba(255,255,255,0.9);
      text-shadow: 0 2px 8px rgba(0,0,0,0.8);
      z-index: 1;
    }

    /* 결과 패널 디자인 변경 (채팅창과 통일감) */
    .result-panel {
      display: flex; width: 100%;
      /* 배경: 짙은 남색/갈색 톤 반투명 (채팅창 스타일) */
      background: rgba(30, 35, 45, 0.85);
      backdrop-filter: blur(10px); /* 블러 효과 */
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 20px; padding: 30px; gap: 30px;
      box-shadow: 0 20px 50px rgba(0,0,0,0.5);
      opacity: 0; height: 280px; 
    }

    .text-col {
      flex: 2; color: #f1f5f9; white-space: pre-wrap;
      overflow: hidden; min-height: 0; 
      font-size: 20px; line-height: 1.6; /* 가독성 확보 */
      font-weight: 500;
    }

    .graph-col {
      flex: 1; min-width: 300px;
      border-left: 2px solid rgba(255,255,255,0.1); 
      padding-left: 20px; 
      display: flex; flex-direction: column; justify-content: center; align-items: center;
    }

    .bar-chart { display: flex; align-items: flex-end; height: 160px; gap: 12px; width: 100%; justify-content: space-around; }
    .bar-col { display: flex; flex-direction: column; align-items: center; height: 100%; justify-content: flex-end; flex: 1; }
    
    /* 그래프 색상: 파스텔톤으로 변경 */
    .bar-stick { 
      width: 70%; 
      background: linear-gradient(to top, #a78bfa, #c4b5fd); /* 연한 보라 */
      border-radius: 6px 6px 0 0; height: 0; transition: height 1s ease-out; 
      box-shadow: 0 0 10px rgba(167, 139, 250, 0.3);
    }
    .bar-txt { font-size: 14px; margin-top: 10px; color: #cbd5e1; text-align: center; white-space: nowrap; }

    .yesno-box { text-align: center; width: 100%; }
    .yesno-big { font-size: 50px; font-weight: bold; margin-bottom: 10px; text-shadow: 0 4px 15px rgba(0,0,0,0.3); }
    .yesno-sub { font-size: 22px; color: #cbd5e1; }

    .radar-wrap { width: 100%; max-width: 260px; aspect-ratio: 1; display: flex; align-items: center; justify-content: center; overflow: visible; }
    .radar-wrap svg { width: 100%; height: 100%; overflow: visible; }
    
    /* 레이더 차트 색상 변경 */
    .radar-polygon { fill: rgba(167, 139, 250, 0.25); stroke: #c4b5fd; stroke-width: 2; transition: opacity 0.5s; }
    .radar-axis { stroke: rgba(255,255,255,0.2); stroke-width: 1; }
    .radar-grid { stroke: rgba(255,255,255,0.1); stroke-width: 1; fill: none; }
    .radar-label { fill: #e2e8f0; font-size: 13px; text-anchor: middle; dominant-baseline: middle; font-family: 'Gowun Dodum', sans-serif; }

    .fail-msg { position: absolute; top: 50%; width: 100%; text-align: center; font-size: 28px; color: #fca5a5; }
  </style>
</head>
<body>

<div id="dimmer"></div>
<div id="app"></div>

<script>
  const base = window.location.origin || (window.location.protocol + "//" + window.location.host);
  let lastKey = null;

  function getImg(id, rev) {
    if (!id) return base + '/tarot-assets/tarot_back.png';
    const folder = rev ? '/reverse/' : '/';
    const suffix = rev ? '_r.png' : '.png';
    return base + '/tarot-assets' + folder + 'tarot_' + id + suffix;
  }

  setInterval(() => {
    fetch(base + '/api/state').then(r => r.json()).then(d => {
      const t = d.tarot;
      if (!t || !t.visible) {
        if (lastKey) {
          document.getElementById('app').innerHTML = '';
          document.getElementById('dimmer').classList.remove('active');
          lastKey = null;
        }
        return;
      }
      const key = `${t.phase}_${(t.selected_indices||[]).join('-')}_${t.question}`;
      if (lastKey !== key) {
        lastKey = key;
        render(t);
      }
      updateTimer(t);
    }).catch(() => {});
  }, 500);

  function render(t) {
    const app = document.getElementById('app');
    const dimmer = document.getElementById('dimmer');
    app.innerHTML = '';
    dimmer.classList.add('active');

    // [1] 선택 단계
    if (t.phase === 'selecting') {
      const count = t.spread_count || 3;
      app.innerHTML = `
        <div class="phase-select">
          <div class="select-info">
            <div class="select-title">${t.requester_nickname || '시청자'}님의 타로 (${count}장)</div>
            <div class="select-sub" id="timer-disp"></div>
          </div>
          <div class="deck-area" id="deck"></div>
        </div>`;
      
      const deck = document.getElementById('deck');
      const angleTotal = 90;
      for(let i=1; i<=78; i++) {
        const el = document.createElement('div');
        el.className = 'card-fan-item';
        const angle = (-angleTotal/2) + (angleTotal/77)*(i-1);
        const isPicked = (t.pending_numbers||[]).includes(i);
        el.style.transform = `translate(-50%, ${isPicked?'-40px':'0'}) rotate(${angle}deg)`;
        if(isPicked) el.classList.add('picked');
        el.style.zIndex = i;
        deck.appendChild(el);
      }
    }

    // [2] 결과 단계
    else if (t.phase === 'revealed') {
      const cards = t.cards || [];
      const indices = t.selected_indices || [];

      let cardsHtml = '';
      indices.forEach((idx, i) => cardsHtml += `<div class="card-slot" id="card-${i}"><span class="card-back-number">${idx}</span></div>`);

      const hasGraph = t.visual_data && (
        t.visual_data.visual_type === 'yes_no' || 
        (t.visual_data.labels && t.visual_data.scores)
      );

      const graphHtml = hasGraph ? `<div class="graph-col" id="graph"></div>` : '';

      app.innerHTML = `
        <div class="phase-reveal">
          <div class="cards-container">${cardsHtml}</div>
          <div class="result-panel" id="panel">
            <div class="text-col" id="text-col">${(t.interpretation || "").replace(/\n/g, "<br>")}</div>
            ${graphHtml}
            <div style="position:absolute; bottom:15px; right:25px; color:#94a3b8; font-size:15px;" id="reveal-timer"></div>
          </div>
        </div>`;

      const textEl = document.getElementById('text-col');
      if (!hasGraph) {
        textEl.style.flex = "1"; 
      }

      if (hasGraph) {
        drawGraph(t.visual_data);
      }

      setTimeout(function() {
        var te = document.getElementById('text-col');
        if (!te) return;
        var fs = parseInt(te.style.fontSize, 10) || 20;
        var minFs = 12;
        while (te.scrollHeight > te.clientHeight && fs > minFs) {
          fs -= 1;
          te.style.fontSize = fs + 'px';
        }
      }, 80);

      const tl = gsap.timeline();
      tl.to('#panel', { opacity: 1, y: 0, duration: 0.5 });
      tl.to('.card-slot', { opacity: 1, y: 0, duration: 0.3, stagger: 0.1 }, "-=0.2");

      indices.forEach((_, i) => {
        const c = cards[i] || {};
        const realSrc = getImg(c.id, c.reversed);
        const rotation = c.reversed ? 'rotate(180deg)' : 'rotate(0deg)';
        
        tl.to(`#card-${i}`, { 
          scaleX: 0, duration: 0.2, ease: "power1.in",
          onComplete: () => {
            const el = document.getElementById(`card-${i}`);
            if(el) {
              el.style.backgroundImage = `url('${realSrc}')`;
              el.style.transform = rotation;
              const numEl = el.querySelector('.card-back-number');
              if (numEl) numEl.style.display = 'none';
            }
          }
        });
        tl.to(`#card-${i}`, { scaleX: 1, duration: 0.3, ease: "back.out(1.5)" });
      });
    }

    else if (t.phase === 'failed') {
      app.innerHTML = `<div class="fail-msg">${t.message}</div>`;
    }
  }

  function drawGraph(v) {
    const el = document.getElementById('graph');
    if (!el) return;

    if (v.visual_type === 'yes_no') {
      const isYes = (v.recommendation === 'YES');
      const color = isYes ? '#86efac' : '#fca5a5'; /* 파스텔톤으로 변경 */
      el.innerHTML = `
        <div class="yesno-box">
          <div class="yesno-big" style="color:${color}">${v.recommendation}</div>
          <div class="yesno-sub">확률: ${v.score || 0}%</div>
        </div>`;
    }
    else if (v.visual_type === 'radar' && v.labels && v.scores) {
      const n = Math.min(v.labels.length, v.scores.length, 8);
      const padding = 38;
      const cx = 100 + padding, cy = 100 + padding, maxR = 82;
      const points = [];
      const labelPoints = [];
      for (let i = 0; i < n; i++) {
        const angle = (i / n) * 2 * Math.PI - Math.PI / 2;
        const r = ((v.scores[i] || 0) / 100) * maxR;
        points.push((cx + r * Math.cos(angle)).toFixed(2) + ',' + (cy + r * Math.sin(angle)).toFixed(2));
        labelPoints.push({ x: cx + (maxR + 12) * Math.cos(angle), y: cy + (maxR + 12) * Math.sin(angle), text: v.labels[i] });
      }
      let grid = '';
      for (let g = 1; g <= 4; g++) {
        const gr = (maxR * g / 4).toFixed(2);
        const circlePoints = [];
        for (let i = 0; i <= n; i++) {
          const a = (i / n) * 2 * Math.PI - Math.PI / 2;
          circlePoints.push((cx + parseFloat(gr) * Math.cos(a)).toFixed(2) + ',' + (cy + parseFloat(gr) * Math.sin(a)).toFixed(2));
        }
        grid += '<polyline class="radar-grid" points="' + circlePoints.join(' ') + '"/>';
      }
      let axes = '';
      for (let i = 0; i < n; i++) {
        const angle = (i / n) * 2 * Math.PI - Math.PI / 2;
        const ex = (cx + maxR * Math.cos(angle)).toFixed(2);
        const ey = (cy + maxR * Math.sin(angle)).toFixed(2);
        axes += '<line class="radar-axis" x1="' + cx + '" y1="' + cy + '" x2="' + ex + '" y2="' + ey + '"/>';
      }
      let labels = '';
      labelPoints.forEach(function(p) {
        labels += '<text class="radar-label" x="' + p.x.toFixed(2) + '" y="' + p.y.toFixed(2) + '">' + (p.text || '').replace(/</g, '&lt;') + '</text>';
      });
      const size = 200 + padding * 2;
      el.innerHTML = '<div class="radar-wrap"><svg viewBox="0 0 ' + size + ' ' + size + '" xmlns="http://www.w3.org/2000/svg">' + grid + axes + '<polygon class="radar-polygon" points="' + points.join(' ') + '"/>' + labels + '</svg></div>';
    }
    else if (v.labels && v.scores) {
      let html = '<div class="bar-chart">';
      const len = Math.min(v.labels.length, v.scores.length, 5);
      for(let i=0; i<len; i++) {
        html += `
          <div class="bar-col">
            <div class="bar-stick" id="bar-${i}"></div>
            <div class="bar-txt">${v.labels[i]}</div>
          </div>`;
      }
      html += '</div>';
      el.innerHTML = html;
      setTimeout(() => {
        for(let i=0; i<len; i++) {
          const b = document.getElementById(`bar-${i}`);
          if(b) b.style.height = (v.scores[i]||0) + '%';
        }
      }, 500);
    }
  }

  function updateTimer(t) {
    if (t.phase === 'selecting') {
      const el = document.getElementById('timer-disp');
      if (el && t.select_deadline_ts) {
        el.innerText = '남은 시간: ' + Math.max(0, Math.floor(t.select_deadline_ts - Date.now()/1000));
      }
    } else if (t.phase === 'revealed') {
      const el = document.getElementById('reveal-timer');
      if (el && t.auto_reset_at_ts) {
        el.innerText = '자동 종료: ' + Math.max(0, Math.floor(t.auto_reset_at_ts - Date.now()/1000));
      }
    }
  }
</script>
</body>
</html>